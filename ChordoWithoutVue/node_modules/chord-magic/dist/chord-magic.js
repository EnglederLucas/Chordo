(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.chordMagic = {})));
}(this, (function (exports) { 'use strict';

  var English = {
    A: ['A'],
    Bb: ['Bb', 'A#', 'Asharp', 'Bflat'],
    B: ['B'],
    C: ['C'],
    Db: ['Db', 'C#', 'Dflat', 'Csharp'],
    D: ['D'],
    Eb: ['Eb', 'D#', 'Eflat', 'Dsharp'],
    E: ['E'],
    F: ['F'],
    Gb: ['Gb', 'F#', 'Gflat', 'Fsharp'],
    G: ['G'],
    Ab: ['Ab', 'G#', 'Aflat', 'Gsharp']
  };

  var NorthernEuropean = {
    A: ['A'],
    Bb: ['B', 'A#', 'Asharp'],
    B: ['H'],
    C: ['C'],
    Db: ['Db', 'C#', 'Dflat', 'Csharp'],
    D: ['D'],
    Eb: ['Eb', 'D#', 'Eflat', 'Dsharp'],
    E: ['E'],
    F: ['F'],
    Gb: ['Gb', 'F#', 'Gflat', 'Fsharp'],
    G: ['G'],
    Ab: ['Ab', 'G#', 'Aflat', 'Gsharp']
  };

  var SouthernEuropean = {
    A: ['La'],
    Bb: ['Tib', 'La#'],
    B: ['Ti'],
    C: ['Do'],
    Db: ['Reb', 'Réb', 'Do#'],
    D: ['Re', 'Ré'],
    Eb: ['Mib', 'Re#'],
    E: ['Mi'],
    F: ['Fa'],
    Gb: ['Solb', 'Sob', 'Fa#'],
    G: ['Sol', 'So'],
    Ab: ['Lab', 'So#', 'Sol#']
  };

  var noteNamings = {
    English: English,
    NorthernEuropean: NorthernEuropean,
    SouthernEuropean: SouthernEuropean
  };

  var chordAddeds = {
    Add9: ['add9', '2'],
    Add11: ['add11', '4'],
    Major6: ['6', 'maj6', 'major6', 'M6'],
    SixNine: ['6/9'],
    PowerChord: ['5'] // duh duh DUH, duh duh DUH-duh, duh duh DUH, duh duh ((c) Deep Purple)
  };

  var chordSuspendeds = {
    Sus4: ['sus4', 'suspended', 'sus'],
    Sus2: ['sus2', 'suspended2']
  };

  var chordQualities = {
    Major: ['', 'major', 'maj', 'M'],
    Minor: ['m', 'minor', 'min'],
    Augmented: ['aug', 'augmented', '+'],
    Diminished: ['dim', 'diminished']
  };

  var chordExtendeds = {
    // sevenths
    Major7: ['Major', ['maj7', 'Maj7', 'M7', '+7']],
    Minor7: ['Minor', ['m7', 'Min7', 'min7', 'minor7', '-7']],
    Dominant7: ['Major', ['7', 'dom7', 'dominant7']],
    Diminished7: ['Diminished', ['dim7', 'diminished7']],

    // true extended
    Major9: ['Major', ['maj9', 'M9', '9']],
    Major11: ['Major', ['maj11', 'M11', '11']],
    Major13: ['Major', ['maj13', 'M13', '13']],

    // weird ones
    AugmentedDominant7: ['Major', ['7#5', '7(#5]']],
    AugmentedMajor7: ['Major', ['maj7#5', 'maj7(#5]']],

    // TODO: I don't know what this one is - can't find it on wikipedia
    Minor9: ['Minor', ['min9', 'm9', 'minor9']]
  };

  function initializeChordRegexes () {
    var map = {};

    Object.keys(noteNamings).forEach(function (noteNaming) {
      map[noteNaming] = initializeChordRegex(noteNamings[noteNaming]);
    });
    return map
  }

  function initializeChordRegex (noteNaming) {
    var chordRegex = {};

    var regexString = createRegexString(noteNaming);
    var regexStringWithParens = createRegexStringWithParens(regexString);

    chordRegex.regexString = regexString;
    chordRegex.regexStringWithParens = regexStringWithParens;
    chordRegex.pattern = new RegExp(regexString);
    chordRegex.patternWithParens = new RegExp(regexStringWithParens);

    return chordRegex
  }

  function optional (pattern) {
    return '(' + pattern + '?)'
  }

  function concatenateAllValues (map) {
    var res = [];
    Object.keys(map).forEach(function (key) {
      res = res.concat(map[key]);
    });
    return res
  }

  // extendeds are different; their values are an array of
  // [type, names]
  function concatenateAllValuesForExtendeds (map) {
    var res = [];
    Object.keys(map).forEach(function (key) {
      res = res.concat(map[key][1]);
    });
    return res
  }

  function createRegexString (noteNaming) {
    return greedyDisjunction(concatenateAllValues(noteNaming), true) + // root note
      optional(greedyDisjunction(
        concatenateAllValues(chordQualities).concat(
          concatenateAllValuesForExtendeds(chordExtendeds)))) + // quality OR seventh
      optional(greedyDisjunction(concatenateAllValues(chordAddeds))) + // add
      optional(greedyDisjunction(concatenateAllValues(chordSuspendeds))) + // sus

      // overridden root note ("over")
      optional('(?:/' + greedyDisjunction(concatenateAllValues(noteNaming)) +
        ')')
  }

  function createRegexStringWithParens (regexString) {
    return '[\\(\\[]' + regexString + '[\\)\\]]'
  }

  function quote (str) {
    // stolen from http://stackoverflow.com/a/3614500/680742
    var regexpSpecialChars = /([[\]^$|()\\+*?{}=!])/gi;

    return str.replace(regexpSpecialChars, '\\$1')
  }

  /**
   * Take an array of strings and make a greedy disjunction regex pattern out of it,
   * with the longest strings first, e.g. ["sus4","sus","sus2"] -->
   *
   * (sus4|sus2|sus)
   * @param allAliases
   * @return
   */
  function greedyDisjunction (aliases, matchingGroup) {
    aliases = aliases.slice(); // copy

    // sort by longest string first
    aliases.sort(function (a, b) {
      var lenCompare = b.length - a.length;
      if (lenCompare !== 0) {
        return lenCompare < 0 ? -1 : 1
      }
      // else sort by normal string comparison
      return a < b ? -1 : 1
    });

    var res = '(';

    if (!matchingGroup) {
      res += '?:'; //  non-matching group
    }

    aliases.forEach(function (alias, i) {
      if (!alias) {
        return // e.g. the "major" quality can be expressed as an empty string, so skip in the regex
      }
      if (i > 0) {
        res += '|';
      }
      res += quote(alias);
    });

    return res + ')'
  }

  var chordRegexes = initializeChordRegexes();

  // given a string and a note naming, return the structured version of it.

  var rootLookups = {};

  Object.keys(noteNamings).forEach(function (noteNaming) {
    rootLookups[noteNaming] = {};
    addReverseLookups(rootLookups[noteNaming], noteNamings[noteNaming]);
  });

  var chordQualitiesLookups = {};

  addReverseLookups(chordQualitiesLookups, chordQualities);

  var chordExtendedsLookups = {};

  addReverseLookupsForExtendeds(chordExtendedsLookups, chordExtendeds);

  var chordSuspendedsLookups = {};

  addReverseLookups(chordSuspendedsLookups, chordSuspendeds);

  var chordAddedsLookups = {};

  addReverseLookups(chordAddedsLookups, chordAddeds);

  function addReverseLookups (reverseDict, dict) {
    Object.keys(dict).forEach(function (key) {
      var arr = dict[key];
      arr.forEach(function (element) {
        reverseDict[element] = key;
      });
    });
  }

  // extendeds are a little different, because they contain both the quality
  // and the extendeds
  function addReverseLookupsForExtendeds (reverseDict, dict) {
    Object.keys(dict).forEach(function (key) {
      var pair = dict[key];
      var quality = pair[0];
      var extendedsArr = pair[1];
      extendedsArr.forEach(function (element) {
        reverseDict[element] = {
          quality: quality,
          extended: key
        };
      });
    });
  }

  function parseObject (match, noteNaming) {
    // match objects is 6 elements:
    // full string, root, quality or extended, added, suspended, overriding root
    // e.g. ["Cmaj7", "C", "maj7", "", "", ""]

    var res = {};

    res.root = rootLookups[noteNaming][match[1]];

    var foundExtended = chordExtendedsLookups[match[2]];
    if (foundExtended) {
      res.quality = foundExtended.quality;
      res.extended = foundExtended.extended;
    } else { // normal quality without extended
      res.quality = chordQualitiesLookups[match[2]];
    }

    if (match[3]) {
      res.added = chordAddedsLookups[match[3]];
    }

    if (match[4]) {
      res.suspended = chordSuspendedsLookups[match[4]];
    }

    if (match[5]) {
      // substring(1) to cut off the slash, because it's e.g. "/F"
      res.overridingRoot = rootLookups[noteNaming][match[5].substring(1)];
    }

    return res
  }

  function parse (str, opts) {
    opts = opts || {};
    var noteNaming = opts.naming || 'English';

    var match = str.match(chordRegexes[noteNaming].pattern);

    return match && parseObject(match, noteNaming)
  }

  function prettyPrint (chord, opts) {
    opts = opts || {};
    var naming = opts.naming || 'English';

    var toPrintableNote;
    // can specify an object here or one of 'English', 'NorthernEuropean', 'SouthernEuropean'
    if (typeof naming === 'string') {
      toPrintableNote = function (note) { return noteNamings[naming][note][0]; };
    } else {
      var noteNamesAsList = Object.keys(noteNamings.English);
      toPrintableNote = function (note) { return naming[noteNamesAsList.indexOf(note)]; };
    }

    // just use the first name for now, but later we may want to add options
    // to allow people to choose how to express chord. e.g. to prefer flats
    // instead of sharps, or prefer certain flats to certain sharps, etc.
    // (e.g. 'Bb' seems to be more common than 'A#', but 'F#' is more common than 'Ab')

    var str = toPrintableNote(chord.root);
    if (chord.extended) {
      str += chordExtendeds[chord.extended][1][0];
    } else {
      str += chordQualities[chord.quality][0];
    }

    if (chord.added) {
      str += chordAddeds[chord.added][0];
    }

    if (chord.suspended) {
      str += chordSuspendeds[chord.suspended][0];
    }

    if (chord.overridingRoot) {
      str += '/' + toPrintableNote(chord.overridingRoot);
    }
    return str
  }

  var chordRoots = [
    'A',
    'Bb',
    'B',
    'C',
    'Db',
    'D',
    'Eb',
    'E',
    'F',
    'Gb',
    'G',
    'Ab'
  ];

  function transposeNote (note, num) {
    var idx = chordRoots.indexOf(note);

    if (idx === -1) {
      throw new Error('unknown note: ' + note)
    }

    idx += num;

    if (idx > 0) {
      idx = idx % chordRoots.length;
    } else {
      idx = (chordRoots.length + idx) % chordRoots.length;
    }

    return chordRoots[idx]
  }

  function transpose (chord, num) {
    if (typeof num !== 'number') {
      throw new Error('you need to provide a number')
    }

    var transposedChord = JSON.parse(JSON.stringify(chord));

    transposedChord.root = transposeNote(chord.root, num);

    if (chord.overridingRoot) {
      transposedChord.overridingRoot = transposeNote(chord.overridingRoot, num);
    }

    return transposedChord
  }

  exports.parse = parse;
  exports.prettyPrint = prettyPrint;
  exports.transpose = transpose;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
